## lab5 实验报告

#### 计45 李昊阳 2014011421

### 练习0：填写已有实验

**本实验依赖实验1/2/3/4。请把你做的实验1/2/3/4的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验1/2/3/4的代码进行进一步改进。** 

答： 这里我使用了图形化的比较/merge工具meld来手动合并。


### 练习1：加载应用程序并执行（需要编码）

在`kern/process/proc.c`的`load_icode`函数中补充下面的代码：
```c
tf->tf_cs = USER_CS;
tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
tf->tf_esp = USTACKTOP;
tf->tf_eip = elf->e_entry;
tf->tf_eflags = FL_IF;
```
这里需要加载的是第一个用户程序，所以我们需要设置好用户程序在中断返回所需要用到的异常帧，使其从中断完成后正确返回并执行。而应用程序要在用户态下正确执行，需要设置好cs,ds,es,ss,eip等段寄存器和指令指针，上述代码便是完成了这样的工作。

简要说明设计实现过程:
- 通过`tf->tf_cs = USER_CS`设置代码段寄存器为用户代码段。
- 通过`tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS`设置数据段和堆栈段为用户数据段。
- 通过`tf->tf_esp = USTACKTOP`设置用户程序的用户态堆栈。
- 通过`tf->tf_eip = elf->e_entry`设置进程的指令寄存器。
- 通过`tf->tf_eflags = FL_IF`使得在用户态可以响应中断。

#### 问题1.1：请描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

答：
从这个用户态进程选择占用CPU到具体执行应用程序第一条指令的经过可以概括为：
- 通过`schedule`找到需要执行的进程或线程。
- 调用`proc_run`切换栈和页表，调用`switch_to`进行上下文的切换。
- `switch_to`返回至`forkret`，进而执行`forkrets`函数。
- 设置栈指针，弹出段寄存器，执行`tf->tf_eip`的指令。
- 由于`tf->tf_eip`被设为`elf->e_entry`，所以用户程序开始执行。


### 练习2：父进程复制自己的内存空间给子进程（需要编码）

父进程创建子进程时，会复制自己的内存空间给子进程，这是通过`copy_range`实现的。在`kern/mm/pmm.c`中完成`copy_range`函数：
```c
void * kva_src = page2kva(page);
void * kva_dst = page2kva(npage);    
memcpy(kva_dst, kva_src, PGSIZE);
ret = page_insert(to, npage, start, perm);
```

简要说明设计实现过程:
- 获得源页的地址。
- 获得目标页的地址。
- 调用`memcpy`将源页拷贝到目标页。
- 设置与物理页的映射关系。

#### 问题2.1 请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

答：
在`copy_range`函数中，不再是创建进程时将所有的内存都拷贝过去，而是将子进程的页目录表中的表项直接指到父进程的页目录表项，然后把原来可写的页表项设置为不可写。这样的话，当进行读操作时，便可以共享资源。当进行写操作时，就会触发异常，一旦触发了异常，就判断该异常是否是因为COW机制造成的。如果是，那么我们就为写的那个进程单独复制一份页面，并替换掉原先的页目录项和页表项，设置页表项可写。


### 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

- fork: 通过`do_fork`函数实现。主要功能是：分配进程的TCB和pid并在链表中加入此进程，最后通过`wakeup_proc`唤醒进程。

- exec: 通过`do_execve`函数实现。首先为了加载新的执行码需要清空用户态内存空间。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0。如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。`load_icode`函数完成了整个复杂的工作。

- wait：通过`do_wait`函数实现。如果pid!=0，表示只找一个进程id号为pid的处于退出状态的子进程，否则找任意一个处于退出状态的子进程；如果此子进程的执行状态不为`PROC_ZOMBIE`，表明此子进程还没有退出，则当前进程设置自己的执行状态为`PROC_SLEEPING`，睡眠原因为`WT_CHILD`（即等待子进程退出），调用`schedule()`函数选择新的进程执行，自己睡眠等待。如果被唤醒，则重复跳回步骤1处执行；如果此子进程的执行状态为`PROC_ZOMBIE`，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列`proc_list`和`hash_list`中删除，并释放子进程的内核堆栈和进程控制块。现在，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。

- exit:通过`do_exit`函数实现。如果是用户进程，则开始回收此用户进程占用的用户态虚拟内存空间。设置当前进程的执行状态`current->state=PROC_ZOMBIE`，当前进程的退出码`current->exit_code=error_code`。此时当前进程已经不能被调度了，需要其父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）。而如果当前进程的父进程`current->parent`处于等待子进程状态，则唤醒父进程，让父进程帮助自己完成最后的资源回收。如果当前进程还有子进程，则要把这些子进程的父进程指针设置为内核线程`initproc`，且各个子进程指针需要插入到`initproc`的子进程链表中。如果某个子进程的执行状态是`PROC_ZOMBIE`，则需要唤醒`initproc`来完成对此子进程的最后回收工作。最后执行schedule()函数，选择新的进程执行。

- 系统调用：初始化系统调用的中断描述符，设置特权级为`DPL_USER`,建立系统调用的用户库准备,在用户进行系统调用时，根据系统调用编号，跳转到相应的入口进行处理。

#### 问题3.1 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

答：
- fork:把子进程加入就绪队列;
- exec:在没有手动要求调度或时间片到的条件下，不改变进程的运行状态，但改变了进程执行的内容（代码变了）；
- wait：可能会将自身转变为等待态（如果没有子进程已经返回）；
- exit：会将自身转为退出态；

#### 问题3.2 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

答：

```
process state changing:

  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+ 
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  + 
                                           -----------------------wakeup_proc----------------------------------
```
### 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

- 用户进程的管理，包括加载、执行等；
- 进程控制中状态的转换等；
- fork/exec/wait/exit等函数的实现；

与原理课上相应的理论知识相对应。

### 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

- `Copy on Write`的具体实现


